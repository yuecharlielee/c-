// https://code.visualstudio.com/docs/editor/tasks
{
    "version": "2.0.0",
    "tasks": [{
        "label": "Compile", // 任務名稱，與launch.json的preLaunchTask相對應
        "command": "g++",   // 要使用的編譯器，C++用g++
        "args": [
            "${file}",
            "-o",    // 指定輸出檔名，不加該引數則預設輸出a.exe，Linux下預設a.out
            "${fileDirname}/${fileBasenameNoExtension}.exe",
            "-g",    // 生成和偵錯有關的資訊
            "-m64", // 不知為何有時會生成16位元應用而無法執行，加上此條可強制生成64位元的
            "-Wall", // 開啟額外警告
            "-static-libgcc",     // 靜態連結libgcc，一般都會加上
            "-fexec-charset=GBK", // 生成的程式使用GBK編碼，不加這條會導致Win下輸出中文亂碼；繁體系統改成BIG5
            // "-std=c11", // 要用的語言標準，根據自己的需要修改。c++可用c++14
        ], // 編譯的命令，其實相當於VSC幫你在終端中輸了這些東西
        "type": "process", // process是把預定義變數和跳脫解析後直接全部傳給command；shell相當於先開啟shell再輸入命令，所以args還會經過shell再解析一遍
        "group": {
            "kind": "build",
            "isDefault": true // 不為true時ctrl shift B就要手動選擇了
        },
        "presentation": {
            "echo": true,
            "reveal": "always", // 執行任務時是否跳轉到終端面板，可以為always，silent，never。具體參見VSC的檔案
            "focus": false,     // 設為true後可以使執行task時焦點聚集在終端，但對編譯C/C++來說，設為true沒有意義
            "panel": "shared"   // 不同的檔案的編譯資訊共用一個終端面板
        },
        "problemMatcher":"$gcc" // 捕捉編譯時終端裡的報錯資訊到問題面板中，修改程式碼後需要重新編譯才會再次觸發
        // 本來有Lint，再開problemMatcher就有雙重報錯，但MinGW的Lint效果實在太差了；用Clang可以註釋掉
    }]
}